#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <unordered_set>
#include <unordered_map>
#include <random>
#include <algorithm>
#include <chrono>
#include <cstdlib>
#include <cmath>

// Daniel Espinosa, Strukov Group, UC Santa Barbara 2024
// Algorithm B
// Refactored to C++
// Algorithmically equivalent to wsatA1.py
// Much faster in wall clock time.

// Compile:
// g++ -std=c++11 -O2 -o B B.cc
// Use: 
// python colorandtest.py -cnf path_to_cnf_file.cnf -out colors.txt
// ./B -cnf path_to_cnf_file.cnf -colors colors.txt -p 0.5 --max_tries 100 --max_loops 1000

// Reads a CNF file in DIMACS format
bool read_dimacs(const std::string& filename, int& num_vars, std::vector<std::vector<int>>& clauses) {
    std::ifstream infile(filename);
    if (!infile) {
        std::cerr << "Error opening CNF file: " << filename << std::endl;
        return false;
    }
    std::string line;
    while (std::getline(infile, line)) {
        if (line.empty()) continue;
        if (line[0] == 'p') {
            std::istringstream iss(line);
            std::string tmp;
            iss >> tmp; // skip 'p'
            iss >> tmp; // skip 'cnf'
            iss >> num_vars;
            int num_clauses;
            iss >> num_clauses;
        } else if (line[0] == 'c' || line[0] == '%' || line[0] == '0') {
            continue;
        } else {
            std::istringstream iss(line);
            std::vector<int> clause;
            int lit;
            while (iss >> lit) {
                if (lit == 0) break;
                clause.push_back(lit);
            }
            if (!clause.empty()) {
                clauses.push_back(clause);
            }
        }
    }
    return true;
}

// Reads colors from a file generated by a Python script
bool read_colors(const std::string& filename, std::unordered_map<int, int>& colors) {
    std::ifstream infile(filename);
    if (!infile) {
        std::cerr << "Error opening colors file: " << filename << std::endl;
        return false;
    }
    int var, color;
    while (infile >> var >> color) {
        colors[var] = color;
    }
    return true;
}

// Evaluates a clause given the current assignment
bool evaluate_clause(const std::vector<int>& clause, const std::unordered_map<int, bool>& assignment) {
    for (int var : clause) {
        int var_abs = std::abs(var);
        bool var_value = assignment.at(var_abs);
        if ((var > 0 && var_value) || (var < 0 && !var_value)) {
            return true;
        }
    }
    return false;
}

// Gets all unsatisfied clauses
std::vector<std::vector<int>> get_unsatisfied_clauses(
    const std::vector<std::vector<int>>& clauses,
    const std::unordered_map<int, bool>& assignment) {
    std::vector<std::vector<int>> unsatisfied;
    for (const auto& clause : clauses) {
        if (!evaluate_clause(clause, assignment)) {
            unsatisfied.push_back(clause);
        }
    }
    return unsatisfied;
}

// Gets all variables from the clauses
std::unordered_set<int> get_variables(const std::vector<std::vector<int>>& clauses) {
    std::unordered_set<int> variables;
    for (const auto& clause : clauses) {
        for (int var : clause) {
            variables.insert(std::abs(var));
        }
    }
    return variables;
}

// Flips the value of a variable in the assignment
void flip_variable(std::unordered_map<int, bool>& assignment, int var) {
    assignment[var] = !assignment[var];
}

// Main algorithm (Algorithm B)
std::tuple<std::unordered_map<int, bool>, int, int, int> AlgorithmB(
    const std::vector<std::vector<int>>& clauses,
    const std::unordered_map<int, int>& colors,
    int max_tries,
    int max_loops,
    double p) {

    int flips = 0; // Actual flips
    std::vector<int> variables_vec;
    for (const auto& var : get_variables(clauses)) {
        variables_vec.push_back(var);
    }

    // Build color_vars mapping from color to variables
    std::unordered_map<int, std::vector<int>> color_vars;
    for (int var : variables_vec) {
        int color = colors.at(var);
        color_vars[color].push_back(var);
    }

    // Random number generators
    std::mt19937 gen(std::random_device{}());
    std::uniform_real_distribution<> dis(0.0, 1.0);

    // Build variable to clauses mapping
    std::unordered_map<int, std::vector<int>> variable_to_clauses;
    for (size_t clause_idx = 0; clause_idx < clauses.size(); ++clause_idx) {
        const auto& clause = clauses[clause_idx];
        for (int var : clause) {
            variable_to_clauses[std::abs(var)].push_back(clause_idx);
        }
    }

    for (int _try = 0; _try < max_tries; ++_try) {
        // Initialize random assignment
        std::unordered_map<int, bool> assignment;
        for (int var : variables_vec) {
            assignment[var] = (dis(gen) < 0.5);
        }

        for (int _loops = 0; _loops < max_loops; ++_loops) {
            auto unsatisfied = get_unsatisfied_clauses(clauses, assignment);

            if (unsatisfied.empty()) { // Found a satisfying assignment
                return std::make_tuple(assignment, _try, _loops, flips);
            }

            // Iterate over colors
            bool break_outer = false;
            for (const auto& kv : color_vars) {
                int color = kv.first;
                const auto& vars_in_color = kv.second;

                // Recompute unsatisfied clauses involving variables of this color
                std::vector<std::vector<int>> unsat_clauses_in_color;
                for (const auto& clause : unsatisfied) {
                    for (int var : clause) {
                        if (std::find(vars_in_color.begin(), vars_in_color.end(), std::abs(var)) != vars_in_color.end()) {
                            unsat_clauses_in_color.push_back(clause);
                            break;
                        }
                    }
                }

                if (unsat_clauses_in_color.empty()) {
                    break_outer = true; // No unsatisfied clauses involving this color
                    break;
                }

                // Choose a random clause from unsat_clauses_in_color
                std::uniform_int_distribution<> clause_dis(0, unsat_clauses_in_color.size() - 1);
                auto& clause = unsat_clauses_in_color[clause_dis(gen)];

                int var_to_flip = -1;
                if (dis(gen) < p) {
                    // Random walk move
                    std::vector<int> vars_in_clause_and_color;
                    for (int var : clause) {
                        if (std::find(vars_in_color.begin(), vars_in_color.end(), std::abs(var)) != vars_in_color.end()) {
                            vars_in_clause_and_color.push_back(std::abs(var));
                        }
                    }
                    if (vars_in_clause_and_color.empty()) {
                        continue; // No variable in clause with this color
                    }
                    std::uniform_int_distribution<> var_dis(0, vars_in_clause_and_color.size() - 1);
                    var_to_flip = vars_in_clause_and_color[var_dis(gen)];
                } else {
                    // Greedy move
                    int min_break = std::numeric_limits<int>::max();
                    std::vector<int> vars_with_min_break;
                    for (int var : vars_in_color) {
                        flip_variable(assignment, var); // Flip the var
                        int unsatisfied_after_flip = get_unsatisfied_clauses(clauses, assignment).size();
                        flip_variable(assignment, var); // Undo the flip

                        if (unsatisfied_after_flip < min_break) {
                            min_break = unsatisfied_after_flip;
                            vars_with_min_break.clear();
                            vars_with_min_break.push_back(var);
                        } else if (unsatisfied_after_flip == min_break) {
                            vars_with_min_break.push_back(var);
                        }
                    }
                    if (vars_with_min_break.empty()) {
                        continue; // No variable to flip
                    }
                    std::uniform_int_distribution<> var_dis(0, vars_with_min_break.size() - 1);
                    var_to_flip = vars_with_min_break[var_dis(gen)];
                }

                flip_variable(assignment, var_to_flip);
                flips++;
            }
            if (break_outer) {
                break;
            }
        }
    }
    return std::make_tuple(std::unordered_map<int, bool>(), -1, -1, flips);
}

int main(int argc, char* argv[]) {
    // Parse command line arguments
    std::string filepath;
    std::string colors_file;
    double probability = 0.0;
    int max_tries = 100;
    int max_loops = 1000;

    // Simple command line parsing
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "-cnf" && i + 1 < argc) {
            filepath = argv[++i];
        } else if (arg == "-colors" && i + 1 < argc) {
            colors_file = argv[++i];
        } else if (arg == "-p" && i + 1 < argc) {
            probability = std::stod(argv[++i]);
        } else if (arg == "--max_tries" && i + 1 < argc) {
            max_tries = std::stoi(argv[++i]);
        } else if (arg == "--max_loops" && i + 1 < argc) {
            max_loops = std::stoi(argv[++i]);
        } else {
            std::cerr << "Unknown argument: " << arg << std::endl;
            return 1;
        }
    }
    // If no file or no colors, explain usage
    if (filepath.empty() || colors_file.empty()) {
        std::cerr << "Usage: " << argv[0] << " -cnf filename -colors colors_file -p probability [--max_tries N] [--max_loops N]" << std::endl;
        return 1;
    }

    // Initialize variables
    int num_vars;
    std::vector<std::vector<int>> clauses;

    if (!read_dimacs(filepath, num_vars, clauses)) {
        std::cerr << "Error reading CNF file." << std::endl;
        return 1;
    }

    std::unordered_map<int, int> colors;
    if (!read_colors(colors_file, colors)) {
        std::cerr << "Error reading colors file." << std::endl;
        return 1;
    }

    auto start_algo_time = std::chrono::high_resolution_clock::now(); // Clock with the shortest tick period
    auto result = AlgorithmB(clauses, colors, max_tries, max_loops, probability);
    auto end_algo_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> time_algo = end_algo_time - start_algo_time;

    if (std::get<1>(result) != -1) {
        // Success
        int tries = std::get<1>(result);
        int loops = std::get<2>(result);
        int flips = std::get<3>(result);
        std::cout << time_algo.count() << " " << 0 << " " << tries << " " << loops << " " << flips << std::endl;
    } else {
        // Fail
        std::cout << 0 << " " << 0 << " " << 0 << " " << 0 << " " << 0 << std::endl;
    }

    return 0;
}
